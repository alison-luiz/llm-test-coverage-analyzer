import OpenAI from "openai";
import Anthropic from "@anthropic-ai/sdk";
import { logger } from "../utils/logger";
import { config } from "../config";
import { CoverageReport, LLMResponse, Gap, PrioritizedGap } from "../types";

export class LLMService {
  private openai?: OpenAI;
  private anthropic?: Anthropic;

  constructor() {
    if (config.llmProvider === "openai") {
      this.openai = new OpenAI({
        apiKey: config.openaiApiKey,
      });
    } else if (config.llmProvider === "anthropic") {
      this.anthropic = new Anthropic({
        apiKey: config.anthropicApiKey,
      });
    }
  }

  async analyzeGaps(coverageReport: CoverageReport): Promise<LLMResponse> {
    try {
      logger.info("Analisando gaps com LLM...");

      if (coverageReport.uncoveredFiles.length === 0) {
        logger.info("‚úÖ Nenhum gap de cobertura encontrado!");
        return {
          analysis:
            "Parab√©ns! O projeto possui 100% de cobertura de c√≥digo. N√£o h√° gaps a serem analisados.",
          identifiedGaps: [],
          prioritization: [],
          recommendations: [
            "Manter a cobertura alta com testes cont√≠nuos.",
            "Considerar mutation testing para validar a qualidade dos testes.",
          ],
        };
      }

      this.displaySelectedFiles(coverageReport);

      const prompt = this.buildAnalysisPrompt(coverageReport);
      const systemPrompt = this.getSystemPrompt();

      let content: string | null = null;

      if (config.llmProvider === "openai" && this.openai) {
        logger.info("ü§ñ Chamando OpenAI API...");
        const response = await this.openai.chat.completions.create({
          model: config.openaiModel,
          messages: [
            {
              role: "system",
              content: systemPrompt,
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          response_format: { type: "json_object" },
        });

        content = response.choices[0].message.content;
        logger.info("‚úÖ Resposta recebida da OpenAI");
      } else if (config.llmProvider === "anthropic" && this.anthropic) {
        logger.info("ü§ñ Chamando Anthropic API...");

        try {
          const response = await this.anthropic.messages.create({
            model: config.anthropicModel,
            max_tokens: 8192, // Aumentar limite para respostas maiores
            system: systemPrompt,
            messages: [
              {
                role: "user",
                content:
                  prompt +
                  "\n\n‚ö†Ô∏è IMPORTANTE: Responda APENAS em formato JSON v√°lido, sem texto adicional antes ou depois do JSON.",
              },
            ],
          });

          logger.info(
            `‚úÖ Resposta recebida da Anthropic. Stop reason: ${response.stop_reason}`
          );

          // Verificar se h√° conte√∫do
          if (!response.content || response.content.length === 0) {
            throw new Error("Resposta da Anthropic n√£o cont√©m conte√∫do");
          }

          const block = response.content[0];
          if (block.type === "text") {
            content = block.text;
            logger.info(`üìù Conte√∫do extra√≠do (${content.length} caracteres)`);
          } else {
            throw new Error(`Tipo de bloco inesperado: ${block.type}`);
          }
        } catch (anthropicError: any) {
          logger.error("‚ùå Erro espec√≠fico da Anthropic:", {
            message: anthropicError.message,
            status: anthropicError.status,
            type: anthropicError.type,
            error: anthropicError.error,
          });
          throw anthropicError;
        }
      } else {
        throw new Error(
          `Provider LLM n√£o configurado corretamente: ${config.llmProvider}`
        );
      }

      if (!content) {
        throw new Error("Resposta vazia do LLM");
      }

      // Tentar extrair JSON se vier com texto extra
      logger.info("üîç Parseando resposta JSON...");
      let parsed;
      try {
        // Tentar extrair JSON se vier cercado por markdown
        const jsonMatch = content.match(/```json\n?([\s\S]*?)\n?```/);
        if (jsonMatch) {
          logger.info(
            "üì¶ JSON encontrado dentro de bloco markdown, extraindo..."
          );
          content = jsonMatch[1];
        }

        parsed = JSON.parse(content);
        logger.info("‚úÖ JSON parseado com sucesso");
      } catch (parseError: any) {
        logger.error("‚ùå Erro ao parsear JSON:", {
          error: parseError.message,
          contentPreview: content.substring(0, 500),
        });
        throw new Error(`Erro ao parsear resposta JSON: ${parseError.message}`);
      }

      logger.info("‚úÖ An√°lise conclu√≠da com sucesso");

      return this.formatLLMResponse(parsed);
    } catch (error: any) {
      logger.error("‚ùå Erro ao analisar com LLM:", {
        message: error.message,
        name: error.name,
        stack: error.stack,
      });
      throw error;
    }
  }

  private getSystemPrompt(): string {
    return `Voc√™ √© um ESPECIALISTA S√äNIOR em Engenharia de Testes de Software, com vasta experi√™ncia em:
- An√°lise de cobertura de c√≥digo (branch, line, function coverage)
- Identifica√ß√£o de edge cases e cen√°rios n√£o testados
- Testes de caminhos alternativos (if/else, switch, loops)
- Testes de condi√ß√µes booleanas complexas (&&, ||, operador tern√°rio)
- An√°lise de qualidade de suites de testes

CONTEXTO DA AN√ÅLISE:
Voc√™ receber√° arquivos com BAIXO BRANCH COVERAGE (<90%), junto com:
1. O c√≥digo-fonte do arquivo
2. Os testes existentes (quando dispon√≠veis)
3. M√©tricas de branch coverage (ex: 80% = 4/5 branches cobertos)
4. Detalhes sobre quais branches/condi√ß√µes N√ÉO est√£o cobertos

SUA MISS√ÉO:
Analisar PROFUNDAMENTE cada arquivo e identificar EXATAMENTE:
1. Quais branches/condi√ß√µes espec√≠ficas n√£o est√£o sendo testadas
2. Por que esses branches s√£o importantes (edge cases, valida√ß√µes, error handling)
3. Como os testes atuais est√£o falhando em cobrir esses cen√°rios
4. Quais casos de teste ESPEC√çFICOS devem ser adicionados

INSTRU√á√ïES CR√çTICAS:
‚úÖ FA√áA:
- Analise o C√ìDIGO FONTE para entender a l√≥gica e identificar branches
- Compare com os TESTES EXISTENTES para ver o que est√° faltando
- Identifique if/else n√£o testados, retornos antecipados, valida√ß√µes de borda
- Sugira casos de teste ESPEC√çFICOS com inputs e outputs esperados
- Priorize por RISCO (critical > high > medium > low)

‚ùå N√ÉO FA√áA:
- N√ÉO invente problemas gen√©ricos
- N√ÉO sugira testes para c√≥digo j√° 100% coberto
- N√ÉO seja vago ("adicione mais testes")
- N√ÉO ignore os testes existentes fornecidos

ESTRUTURA DA RESPOSTA (JSON):
{
  "analysis": "An√°lise geral do estado da cobertura e padr√µes identificados",
  "identifiedGaps": [
    {
      "file": "nome do arquivo",
      "lines": [n√∫meros das linhas com branches n√£o cobertos],
      "description": "Descri√ß√£o ESPEC√çFICA do branch n√£o coberto (ex: 'else do if(x > 0) na linha 45')",
      "codeSnippet": "trecho do c√≥digo relevante"
    }
  ],
  "prioritization": [
    {
      "priority": "CRITICAL|HIGH|MEDIUM|LOW",
      "reasoning": "Por que este gap √© desta prioridade (considere: error handling, edge cases, data corruption, security)",
      "suggestedTests": [
        "Teste ESPEC√çFICO 1: Input X deve retornar Y para cobrir branch Z",
        "Teste ESPEC√çFICO 2: Quando condi√ß√£o W, esperar comportamento Q"
      ]
    }
  ],
  "recommendations": [
    "Recomenda√ß√µes PR√ÅTICAS e ACION√ÅVEIS para melhorar a cobertura",
    "Sugest√µes de refatora√ß√£o se o c√≥digo dificulta testes"
  ]
}

SEJA PRECISO, T√âCNICO E ACION√ÅVEL. Cada sugest√£o deve poder ser implementada imediatamente.`;
  }

  private buildAnalysisPrompt(report: CoverageReport): string {
    const filesInfo = report.uncoveredFiles
      .slice(0, 5)
      .map((file, idx) => {
        const branchDetails =
          file.detailedBranches && file.detailedBranches.length > 0
            ? file.detailedBranches
                .map(
                  (b) =>
                    `  - Linha ${b.line}: tipo '${b.type}' - ${b.uncoveredBranches.length} de ${b.totalBranches} branches n√£o cobertos`
                )
                .join("\n")
            : "  Informa√ß√£o detalhada n√£o dispon√≠vel";

        return `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ARQUIVO ${idx + 1}: ${file.filePath.split("/").pop() || file.filePath}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä M√âTRICAS:
Branch Coverage: ${file.branchCoverage?.toFixed(1)}% (${file.coveredBranches}/${
          file.totalBranches
        } branches cobertos)
${
  file.uncoveredLines.length > 0
    ? `Linhas n√£o cobertas: ${file.uncoveredLines.slice(0, 10).join(", ")}${
        file.uncoveredLines.length > 10 ? "..." : ""
      }`
    : "Todas as linhas est√£o cobertas"
}

üîÄ BRANCHES N√ÉO COBERTOS:
${branchDetails}

üìù C√ìDIGO FONTE COMPLETO:
\`\`\`javascript
${file.sourceCode || "C√≥digo n√£o dispon√≠vel"}
\`\`\`

üß™ TESTES EXISTENTES:
${
  file.testCode
    ? `\`\`\`javascript\n${file.testCode.substring(0, 3000)}\n\`\`\``
    : "‚ö†Ô∏è NENHUM TESTE ENCONTRADO - Este √© um problema cr√≠tico!"
}

`;
      })
      .join("\n");

    return `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    RELAT√ìRIO DE AN√ÅLISE DE BRANCH COVERAGE                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä VIS√ÉO GERAL DO REPOSIT√ìRIO:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Reposit√≥rio: ${report.repositoryName}
Cobertura de Linhas: ${report.coveragePercentage}%
Total de Linhas: ${report.totalLines} (${report.coveredLines} cobertas)
Arquivos com Branch Coverage < 90%: ${report.uncoveredFiles.length}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

${filesInfo}

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                           INSTRU√á√ïES PARA AN√ÅLISE                             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Para CADA arquivo acima, voc√™ DEVE:

1Ô∏è‚É£ IDENTIFICAR OS BRANCHES ESPEC√çFICOS N√ÉO COBERTOS
   - Analise o c√≥digo e identifique exatamente quais if/else, switch, tern√°rios n√£o est√£o testados
   - Use as informa√ß√µes de "BRANCHES N√ÉO COBERTOS" como guia
   - Cite linha e tipo de branch (ex: "linha 45: else do if n√£o coberto")

2Ô∏è‚É£ ANALISAR OS TESTES EXISTENTES
   - Veja o que J√Å est√° sendo testado
   - Identifique por que os branches n√£o cobertos n√£o s√£o atingidos
   - Note inputs/cen√°rios que faltam

3Ô∏è‚É£ SUGERIR TESTES ESPEC√çFICOS
   - Para cada branch n√£o coberto, sugira UM teste espec√≠fico
   - Inclua: input, expected output, qual branch ser√° coberto
   - Seja MUITO espec√≠fico (n√£o gen√©rico)

4Ô∏è‚É£ PRIORIZAR POR RISCO
   - CRITICAL: error handling, security, data corruption
   - HIGH: valida√ß√µes importantes, edge cases cr√≠ticos
   - MEDIUM: paths alternativos relevantes
   - LOW: branches de otimiza√ß√£o/performance

‚ö†Ô∏è ATEN√á√ÉO: Analise APENAS os ${report.uncoveredFiles.length} arquivos listados acima. N√£o invente problemas.

Responda AGORA em JSON com an√°lise detalhada e acion√°vel.`;
  }

  private extractRelevantCode(
    sourceCode: string,
    uncoveredLines: number[]
  ): string {
    const lines = sourceCode.split("\n");
    const relevantLines: string[] = [];

    uncoveredLines.forEach((lineNum) => {
      const start = Math.max(0, lineNum - 3);
      const end = Math.min(lines.length, lineNum + 3);

      for (let i = start; i < end; i++) {
        const marker = uncoveredLines.includes(i + 1) ? ">>> " : "    ";
        relevantLines.push(`${marker}${i + 1}: ${lines[i]}`);
      }
      relevantLines.push("");
    });

    return relevantLines.join("\n");
  }

  private formatLLMResponse(parsed: any): LLMResponse {
    return {
      analysis: parsed.analysis || "",
      identifiedGaps: parsed.identifiedGaps || [],
      prioritization: parsed.prioritization || [],
      recommendations: parsed.recommendations || [],
    };
  }

  private displaySelectedFiles(report: CoverageReport): void {
    const filesToAnalyze = report.uncoveredFiles.slice(0, 5);
    const totalFiles = report.uncoveredFiles.length;

    console.log("\n" + "=".repeat(70));
    console.log("ü§ñ ENVIANDO PARA AN√ÅLISE DO LLM");
    console.log("=".repeat(70));
    console.log(
      `üìä Total de arquivos com branch coverage < 90%: ${totalFiles}`
    );
    console.log(
      `üì§ Enviando para an√°lise: ${filesToAnalyze.length} arquivo(s)`
    );

    if (totalFiles > 5) {
      console.log(
        `‚ö†Ô∏è  Limitado a 5 arquivos para n√£o exceder o limite de tokens`
      );
    }

    console.log("\nüìÅ ARQUIVOS SELECIONADOS:\n");

    filesToAnalyze.forEach((file, idx) => {
      const branchPercentage = file.branchCoverage?.toFixed(1) || "N/A";
      const testStatus = file.testCode
        ? "‚úÖ Teste encontrado"
        : "‚ùå Teste n√£o encontrado";

      console.log(`${idx + 1}. ${file.filePath}`);
      console.log(
        `   üîÄ Branch Coverage: ${branchPercentage}% (${file.coveredBranches}/${file.totalBranches})`
      );
      console.log(`   üß™ ${testStatus}`);
    });

    console.log("\n" + "=".repeat(70));
    console.log("‚è≥ Aguardando resposta do LLM...\n");
  }
}
